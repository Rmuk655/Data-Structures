#include <iostream>
#include <vector>
#include <string>

using namespace std;

// Time complexity = O(n)
// Space complexity = O(n)
// Extra space complexity due to the function reorder = O(1)

// Defining node of a singly linked list which stores the integer stored in the current node and address of the next node.
struct node
{
    int data;
    node *next;
};

// Function to create a new node and add it to the existing linked list with head pointer head, value val.
struct node *create_node(struct node *head, int val)
{
    // Dealing with the special case when the linked list doesnt exist - head == nullptr.
    // We just create the new node, store it in head itself and return head after updating its data and next fields.
    if (head == nullptr)
    {
        head = new node();
        head->data = val;
        head->next = nullptr;
        return head;
    }
    // We use a temp pointer to traverse through the list to reach the last element to which we attach the new node as it's next.
    struct node *temp = head;
    while (temp->next != nullptr)
    {
        temp = temp->next;
    }
    // Creating a new node, updating it's data, next attributes and attaching it to the list
    temp->next = new node();
    temp->next->data = val;
    temp->next->next = nullptr;
    // We return the head pointer as we always traverse through the list starting from the head.
    return head;
}

// Reorder function which performs the reordering.
struct node *reorder(struct node *head)
{
    // If there are 0/1/2 elements in the linked list we need not do anything. Hence we directly return the head pointer.
    if (head == nullptr || head->next == nullptr || head->next->next == nullptr)
    {
        return head;
    }
    // Using a series of temp variables to store head, head->next.
    // temp2 is used to store head->next so we can reattach the nodes at even positions to the end of the last node at odd position.
    struct node *temp = head, *temp1 = head->next, *temp2 = temp1;
    while (temp != nullptr && temp->next != nullptr && temp->next->next != nullptr)
    {
        temp->next = temp1->next;
        temp1->next = temp1->next->next;
        temp = temp->next;
        temp1 = temp1->next;
    }
    // Reattaching to complete the linked list.
    temp->next = temp2;
    return head;
}

// Print function is used to print the values stored in the nodes of the list starting from the head till the last node.
void print(struct node *head)
{
    while (head->next != nullptr)
    {
        cout << head->data << ", ";
        head = head->next;
    }
    cout << head->data << endl;
}

// // Helper function used for running the test function. This is used to generate the actual output so that we can compare it to the
// // expected output in the test function and check if the test cases pass or not.
// string list_to_string(struct node *head)
// {
// // We store the actual output in the string result and return it.
//     string result;
// // String result is generated by traversing through the list, converting the integer data of each node to a string and append
// // it to the existing result string.
//     while (head != nullptr)
//     {
//         result += to_string(head->data);
// // For the last element we need not append ", " and hence we have to check if head->next is nullptr or not (which indicates if
// // it is a last element or not)
//         if (head->next)
//             result += ",";
//         head = head->next;
//     }
//     return result;
// }

// // Test function
// void test(vector<int> input, string expected)
// {
//     // Creating the linked list using the vector of integers we get from the test_check function.
//     node *head = nullptr;
//     for (int val : input)
//     {
//         head = create_node(head, val);
//     }

//     // We reorder the linked list and generate the output string.
//     head = reorder(head);
//     string output = list_to_string(head);

//     // Printing the input list of numbers and corresponding expected, actual outputs to manually check if they match.
//     cout << "Input: ";
//     for (size_t i = 0; i < input.size(); i++)
//     {
//         cout << input[i] << (i + 1 < input.size() ? "," : "");
//     }
//     cout << "\nExpected: " << expected << "\nGot:      " << output << "\n";

//     // Comparing expected and actual output.
//     if (output == expected)
//         cout << "Test Passed\n\n";
//     else
//         cout << "Test Failed\n\n";
// }

// // Contains the set of test cases to be run for checking the validity of the code.
// // A variety of cases have been tried and tested and the code has passed these test cases.
// void test_check()
// {
//     test({1, 2, 3, 4, 5}, "1,3,5,2,4");
//     test({2, 1, 3, 5, 6, 4, 7}, "2,3,6,7,1,5,4");
//     test({10, 20}, "10,20");
//     test({5}, "5");
//     test({11, 22, 33, 44, 55, 66}, "11,33,55,22,44,66");
//     test({1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, "1,3,5,7,9,2,4,6,8,10");
//     test({}, "");                                 // empty list
//     test({42}, "42");                             // single element
//     test({100, 200, 300}, "100,300,200");         // odd count 3
//     test({1, 2, 3, 4}, "1,3,2,4");                // even count 4
//     test({-1, -2, -3, -4, -5}, "-1,-3,-5,-2,-4"); // negative numbers
//     test({1, 1, 1, 1, 1}, "1,1,1,1,1");           // all same
//     test({9, 8, 7, 6, 5}, "9,7,5,8,6");           // descending order
//     cout << "All test cases passed" << endl;
// }

int main()
{
    // To run the test function by uncommenting.
    // test_check();
    // Initially the linked list is empty, hence the head pointer points to null.
    struct node *head = nullptr;
    // Taking user input in string format. Ex: If input is 2, 3, -1, then s = "2,".
    string s;
    cin >> s;
    // We take inputs until we reach -1 as per the instructions in the question.
    while (s != "-1")
    {
        // We remove the ',' using the built-in pop_back function of strings.
        s.pop_back();
        // We convert the left over string to a number and insert it into the linked list.
        head = create_node(head, stoi(s));
        // Taking user input in string format. Ex: If input is 2, 3, -1, then s = "3," now as "2," has been taken in above.
        cin >> s;
    }
    // print(head);
    head = reorder(head);
    // We print the list after reordering.
    print(head);
}